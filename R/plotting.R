#' Plot Summary Panel
#'
#' Plots a panel of three plots: the probability of finding a fault per round,
#' the number of remaining faults per round, and the observed effect sizes per round.
#'
#' @param literature (`list()`)\cr
#'   A list containing the simulated literature, generated by [simulate_literature()].
#' @param study_id (`character()` or `integer()`)\cr
#'   A vector of (possibly multiple) unique identifiers of studies indicating for which studies the plot should be generated.
#'   If `NULL`, all studies in `literature` are plotted. Default is `NULL`.
#'
#' @return `patchwork` / `gg` object
#'
#' @examples
#' # Create study and agent
#' agent <- create_agents(
#'   agent_id = "Alice",
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   study_id = "Alice2022", agent_id = "Alice",
#'   N = 30, resources = 1000, cost = 4, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#' # Plot the summary panel
#' plot_summary_panel(lit)
#'
#' @export
plot_summary_panel <- function(literature, study_id = NULL) {
  # Check if patchwork is available
  if (!requireNamespace("patchwork", quietly = TRUE)) {
    stop("The 'patchwork' package is needed for this function to work. Please install it.", call. = FALSE)
  }
  # Assertions
  assert_literature(literature)
  assert(
    check_string(study_id),
    check_int(study_id, lower = 1),
    check_null(study_id)
  )
  possible_study_ids <- setdiff(names(literature), c("complete_studies", "seed", "keep_seed_const"))
  assert_subset(study_id, possible_study_ids)
  if (is.null(study_id)) {
    study_id <- possible_study_ids
  }

  # Create Plots
  # Handling legends manually since patchworks plot_layout(guides = "collect") does not reduce to 1
  gg1 <- plot_prob_fault_this_round(literature, study_id, cbr = TRUE)
  gg2 <- plot_rem_faults(literature, study_id) +
    ggplot2::guides(color = "none")
  gg3 <- plot_obs_effect_sizes(literature, study_id, true_effect = TRUE) +
    ggplot2::guides(color = "none")

  # Combine plots to Panel
  panel <- (gg1 / gg2 / gg3) +
    patchwork::plot_layout(guide = "collect")

  suppress_na_warnings(panel)
}

#' Plot Probability of Finding a Fault per Round
#'
#' @param literature (`list()`)\cr
#' A list containing the simulated literature, generated by [simulate_literature()].
#' @param study_id (`character()` or `integer()`)\cr
#' A vector of (possibly multiple) unique identifiers of studies indicating for which studies the plot should be generated.
#' If `NULL`, all studies in `literature` are plotted. Default is `NULL`.
#' @param cbr (`logical()`)\cr
#' If `TRUE`, the cost-benefit-ratios will be plotted additionally. Default is `TRUE`.
#'
#' @return
#' A `ggplot` object that can be further customized using the `ggplot2` package.
#'
#' @details
#' The cost-benefit-ratios can be plotted as dashed lines in the same plot as the probability of finding a fault in the current round.
#' If this probability is smaller than the cost-benefit-ratio, the agent will stop searching.
#'
#' @examples
#' if (requireNamespace(c("ggplot2", "patchwork"), quietly = TRUE)) {
#' library(ggplot2)
#' library(patchwork)
#'
#' # Create study and agent
#' agent <- create_agents(
#'   agent_id = "Alice",
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   study_id = "Alice2022", agent_id = "Alice",
#'   N = 30, resources = 1000, cost = 400, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#' # Plot the probability of finding a fault per round
#' plot_prob_fault_this_round(lit)
#' }
#'
#' @export
plot_prob_fault_this_round <- function(literature, study_id = NULL, cbr = TRUE) {
  # Check if ggplot2 is available
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("The 'ggplot2' package is needed for this function to work. Please install it.", call. = FALSE)
  }
  # Assertions
  assert_literature(literature)
  assert(
    check_character(study_id, any.missing = FALSE),
    check_integerish(study_id, lower = 1, any.missing = FALSE),
    check_null(study_id)
  )
  possible_study_ids <- setdiff(names(literature), c("complete_studies", "seed", "keep_seed_const"))
  assert_subset(study_id, possible_study_ids)
  if (is.null(study_id)) {
    study_id <- possible_study_ids
  }
  assert_flag(cbr)

  # Extract desired studies
  studies <- literature[study_id]

  # Extract vectors of probability of finding a fault in the current round
  probs <- lapply(studies, function(x) {
    x[["p_fault_this_round"]]
  })
  # Pad vectors to assure same length
  probs <- lapply(probs, function(x) {
    length(x) <- max(lengths(probs))
    x
  })

  # Build up data.frame in long format for plotting
  df <- data.frame(
    study_id = rep(names(probs), each = length(probs[[1]])),
    round = rep(seq_along(probs[[1]]), times = length(probs)),
    prob = unname(unlist(probs))
  )

  # Image generation
  gg <- ggplot2::ggplot(df, ggplot2::aes(y = prob, x = round, color = study_id)) +
    ggplot2::geom_line() +
    ggplot2::scale_y_continuous(limits = c(0, 1)) +
    ggplot2::labs(title = "Probability of Finding a Fault in the Current Round",
                  x = "Round", y = "Probability") +
    ggplot2::theme_minimal()

  # Show cost-to-benefit ratios if desired
  if (cbr) {
    # Crate vector of cost-benefit-ratios
    row_indices <- literature[["complete_studies"]][["study_id"]] %in% study_id
    cbrs <- literature[["complete_studies"]][row_indices, "cost"] / literature[["complete_studies"]][row_indices, "benefit"]
    df_cbr <- data.frame(
      study_id = study_id,
      cbr = cbrs
    )
    # Modify plot
    gg <- gg + ggplot2::geom_hline(data = df_cbr, ggplot2::aes(yintercept = cbrs, color = study_id), linetype = "dashed") +
      ggplot2::labs(title = paste0("Probability of Finding a Fault in the Current Round\n",
                                   "(with cost-to-benefit ratios)"))
    suppress_na_warnings(gg)
  } else {
    suppress_na_warnings(gg)
  }
}

#' Plot Observed Effect Sizes per Round
#'
#' @param literature (`list()`)\cr
#' A list containing the simulated literature, generated by [simulate_literature()].
#' @param study_id (`character()` or `integer()`)\cr
#' A vector of (possibly multiple) unique identifiers of studies indicating for which studies the plot should be generated.
#' If `NULL`, all studies in `literature` are plotted. Default is `NULL`.
#' @param true_effect (`logical()`)\cr
#' If `TRUE`, the true effect sizes of each study will be plotted additionally. Default is `TRUE`.
#'
#' @return
#' A `ggplot` object that can be further customized using the `ggplot2` package.
#'
#' @examples
#' if (requireNamespace("ggplot2", quietly = TRUE)) {
#' library(ggplot2)
#'
#' # Create study and agent
#' agent <- create_agents(
#'   agent_id = "Alice",
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   study_id = "Alice2022", agent_id = "Alice",
#'   N = 30, resources = 1000, cost = 400, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#' # Plot the observed effect sizes per round
#' plot_obs_effect_sizes(lit)
#' }
#'
#' @export
plot_obs_effect_sizes <- function(literature, study_id = NULL, true_effect = TRUE) {
  # Check if ggplot2 is available
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("The 'ggplot2' package is needed for this function to work. Please install it.", call. = FALSE)
  }
  # Assertions
  assert_literature(literature)
  assert(
    check_character(study_id, any.missing = FALSE),
    check_integerish(study_id, lower = 1, any.missing = FALSE),
    check_null(study_id)
  )
  possible_study_ids <- setdiff(names(literature), c("complete_studies", "seed", "keep_seed_const"))
  assert_subset(study_id, possible_study_ids)
  if (is.null(study_id)) {
    study_id <- possible_study_ids
  }
  assert_flag(true_effect)

  # Extract desired studies
  studies <- literature[study_id]

  # Extract vectors of probability of finding a fault in the current round
  obs_effect_sizes <- lapply(studies, function(x) {
    x[["observed_effect_sizes"]]
  })
  # Pad vectors to assure same length
  obs_effect_sizes <- lapply(obs_effect_sizes, function(x) {
    length(x) <- max(lengths(obs_effect_sizes))
    x
  })
  # Replace all values after stopping rounds with NA
  n_rounds <- lapply(studies, function(x) {
    x[["stopped_in_round"]]
  })
  obs_effect_sizes_trimmed <- Map(function(effect_sizes, stop_round) {
    # Only replace with NAs if stop_round is not the last round
    if (stop_round != length(effect_sizes)) {
      effect_sizes[seq(stop_round + 1, length(effect_sizes))] <- NA
    }
    effect_sizes
  }, obs_effect_sizes, n_rounds)

  # Build up data.frame in long format for plotting
  df <- data.frame(
    study_id = rep(names(obs_effect_sizes_trimmed), each = length(obs_effect_sizes_trimmed[[1]])),
    round = rep(seq_along(obs_effect_sizes_trimmed[[1]]), times = length(obs_effect_sizes_trimmed)),
    obs_effect_sizes = unname(unlist(obs_effect_sizes_trimmed))
  )

  # Image generation
  gg <- ggplot2::ggplot(df, ggplot2::aes(y = obs_effect_sizes, x = round, color = study_id)) +
    ggplot2::geom_line() +
    ggplot2::labs(title = "Observed Effect Sizes per Round",
                  x = "Round", y = "Effect Size") +
    ggplot2::theme_minimal()

  # Show true effect sizes if desired
  if (true_effect) {
    # Create vector of cost-benefit-ratios
    obj_effect_size <- lapply(studies, function(x) {
      x[["obj_effect_size"]]
    })
    # Pad vectors to assure same length
    obj_effect_size <- lapply(obj_effect_size, function(x) {
      length(x) <- max(lengths(obj_effect_size))
      x
    })
    df_true_effect <- data.frame(
      study_id = study_id,
      obj_effect_size = unname(unlist(obj_effect_size))
    )

    # Modify plot
    gg <- gg + ggplot2::geom_hline(data = df_true_effect, ggplot2::aes(yintercept = obj_effect_size, color = study_id), linetype = "dashed") +
      ggplot2::labs(title = paste0("Observed Effect Sizes per Round\n(with true effect sizes)"))

    suppress_na_warnings(gg)
  } else {
    suppress_na_warnings(gg)
  }
}


#' Plot Number of Remaining Faults per Round
#'
#' @param literature (`list()`)\cr
#' A list containing the simulated literature, generated by [simulate_literature()].
#' @param study_id (`character()` or `integer()`)\cr
#' A vector of (possibly multiple) unique identifiers of studies indicating for which studies the plot should be generated.
#' If `NULL`, all studies in `literature` are plotted. Default is `NULL`.
#'
#' @return
#' A `ggplot` object that can be further customized using the `ggplot2` package.
#'
#' @examples
#' if (requireNamespace("ggplot2", quietly = TRUE)) {
#' library(ggplot2)
#'
#' # Create study and agent
#' agent <- create_agents(
#'   agent_id = "Alice",
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   study_id = "Alice2022", agent_id = "Alice",
#'   N = 30, resources = 1000, cost = 400, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#' # Plot the number of remaining faults per round
#' plot_rem_faults(lit)
#' }
#'
#' @export
plot_rem_faults <- function(literature, study_id = NULL) {
  # Check if ggplot2 is available
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("The 'ggplot2' package is needed for this function to work. Please install it.", call. = FALSE)
  }
  # Assertions
  assert_literature(literature)
  assert(
    check_character(study_id, any.missing = FALSE),
    check_integerish(study_id, lower = 1, any.missing = FALSE),
    check_null(study_id)
  )
  possible_study_ids <- setdiff(names(literature), c("complete_studies", "seed", "keep_seed_const"))
  assert_subset(study_id, possible_study_ids)
  if (is.null(study_id)) {
    study_id <- possible_study_ids
  }

  # Extract desired studies
  studies <- literature[study_id]

  # Extract vectors of remaining faults per round
  n_rem_faults <- lapply(studies, function(x) {
    rev(cumsum(x[["fault_indicators"]]))
  })
  # Pad vectors to assure same length
  n_rem_faults <- lapply(n_rem_faults, function(x) {
    length(x) <- max(lengths(n_rem_faults))
    x
  })

  df <- data.frame(
    study_id = rep(names(n_rem_faults), each = length(n_rem_faults[[1]])),
    round = rep(seq_along(n_rem_faults[[1]]), times = length(n_rem_faults)),
    n_rem_faults = unname(unlist(n_rem_faults))
  )

  # Image generation
  gg <- ggplot2::ggplot(df, ggplot2::aes(y = n_rem_faults, x = round, color = study_id)) +
    ggplot2::geom_line() +
    ggplot2::labs(title = "Number of Remaining Faults per Round",
                  x = "Round", y = "# Remaining Faults") +
    ggplot2::theme_minimal()

  suppress_na_warnings(gg)
}

#' Plot Histogram of Final Observed Effect Sizes
#'
#' Plots the distribution of the final observed effect sizes across the specified studies as a historgram.
#'
#' @param literature (`list()`)\cr
#' A list containing the simulated literature, generated by [simulate_literature()].
#' @param study_id (`character()` or `integer()`)\cr
#' A vector of (possibly multiple) unique identifiers of studies indicating for which studies the plot should be generated.
#' If `NULL`, all studies in `literature` are plotted. Default is `NULL`.
#'
#' @return
#' A `ggplot` object that can be further customized using the `ggplot2` package.
#'
#' @examples
#' if (requireNamespace("ggplot2", quietly = TRUE)) {
#' library(ggplot2)
#'
#' # Create study and agent
#' agent <- create_agents(
#'   agent_id = seq(1, 20),
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   agent_id = seq(1, 20),
#'   N = 30, resources = 1000, cost = 400, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#' # Plot the number of remaining faults per round
#' plot_histogram_final_effect_sizes(lit)
#' }
#'
#' @export
plot_histogram_final_effect_sizes <- function(literature, study_id = NULL) {
  # Check if ggplot2 is available
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("The 'ggplot2' package is needed for this function to work. Please install it.", call. = FALSE)
  }
  # Assertions
  assert_literature(literature)
  assert(
    check_character(study_id, any.missing = FALSE),
    check_integerish(study_id, lower = 1, any.missing = FALSE),
    check_null(study_id)
  )
  possible_study_ids <- setdiff(names(literature), c("complete_studies", "seed", "keep_seed_const"))
  assert_subset(study_id, possible_study_ids)
  if (is.null(study_id)) {
    study_id <- possible_study_ids
  }

  # Extract desired studies
  studies <- literature[study_id]

  # Extract vectors of final observed effect sizes
  final_observed_effect_sizes <- vapply(studies, function(x) x[["observed_effect_sizes"]][x[["stopped_in_round"]]], numeric(1))

  # Construct data.frame for plotting
  df <- data.frame(
    final_obsereved_effect_sizes = final_observed_effect_sizes
  )

  # Image generation
  gg <- ggplot2::ggplot(df, aes(x = final_obsereved_effect_sizes)) +
    ggplot2::geom_histogram() +
    ggplot2::labs(title = "Histogram of Final Observed Effect Sizes",
                  x = "Final observed effect size",
                  y = "Frequency") +
    ggplot2::theme_minimal()

  suppress_na_warnings(gg)
}

#' Plot Histogram of Number of Remaining Faults
#'
#' Plots the distribution of the number of remaining faults across the specified studies as a histogram.
#'
#' @param literature (`list()`)\cr
#' A list containing the simulated literature, generated by [simulate_literature()].
#' @param study_id (`character()` or `integer()`)\cr
#' A vector of (possibly multiple) unique identifiers of studies indicating for which studies the plot should be generated.
#' If `NULL`, all studies in `literature` are plotted. Default is `NULL`.
#' @param type (`character()`)\cr
#' a character string indicating whether to plot the absolute number of undiscovered faults or the number of undiscovered
#' faults relative to the total number of faults that existed in the study. Can be either `"absolute"` or `"relative"`.
#' Default is `"relative"`.
#'
#' @return
#' A `ggplot` object that can be further customized using the `ggplot2` package.
#'
#' @examples
#' if (requireNamespace("ggplot2", quietly = TRUE)) {
#' library(ggplot2)
#'
#' # Create study and agent
#' agent <- create_agents(
#'   agent_id = seq(1, 20),
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   agent_id = seq(1, 20),
#'   N = 30, resources = 1000, cost = 400, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#' # Plot the number of remaining faults per round
#' plot_histogram_n_faults(lit)
#' }
#'
#' @export
plot_histogram_n_faults <- function(literature, study_id = NULL, type = "relative") {
  # Check if ggplot2 is available
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("The 'ggplot2' package is needed for this function to work. Please install it.", call. = FALSE)
  }
  # Assertions
  assert_literature(literature)
  assert_string(type)
  assert_choice(type, c("absolute", "relative"))
  assert(
    check_character(study_id, any.missing = FALSE),
    check_integerish(study_id, lower = 1, any.missing = FALSE),
    check_null(study_id)
  )
  possible_study_ids <- setdiff(names(literature), c("complete_studies", "seed", "keep_seed_const"))
  assert_subset(study_id, possible_study_ids)
  if (is.null(study_id)) {
    study_id <- possible_study_ids
  }

  # Extract desired studies
  studies <- literature[study_id]

  # Extract vector of number of undiscovered faults per study
  n_faults_undiscovered <- vapply(studies, function(x) {
    start_index <- x[["stopped_in_round"]] + 1
    end_index <- length(x[["fault_indicators"]])

    # Create a sequence only if the start index is less than or equal to the end index
    indices <- if (start_index <= end_index) seq(start_index, end_index) else integer(0)

    sum(x[["fault_indicators"]][indices], na.rm = TRUE)
  }, numeric(1))

  # Construct data.frame for plotting depending on type
  if (type == "relative") {
    n_faults_total <- vapply(studies, function(x) sum(x[["fault_indicators"]]), numeric(1))
    df = data.frame(
      n_faults_undiscovered = n_faults_undiscovered / n_faults_total
    )
  } else if (type == "absolute") {
    df = data.frame(
      n_faults_undiscovered = n_faults_undiscovered
    )
  }

  # Image generation
  gg <- ggplot2::ggplot(df, aes(x = n_faults_undiscovered)) +
    ggplot2::geom_histogram() +
    ggplot2::labs(title = "Histogram of Number of Undiscovered Faults",
                  x = "Number of undiscovered faults",
                  y = "Frequency") +
    ggplot2::theme_minimal()

  suppress_na_warnings(gg)
}

#' Plot Probability Distributions over Rounds as Heatmap
#'
#' Plots the discrete probability distributions simulated through [simulate_literature()] per round as a heatmap.
#'
#' @param literature (`list()`)\cr
#' A list containing the simulated literature, generated by [simulate_literature()].
#' @param study_id (`character()` or `integer()`)\cr
#' A unique identifier of a study indicating for which study the plot should be generated.
#' @param type (`character()`)\cr
#' a character string indicating the type of distribution to plot. Can be either "after_effect" or "after_fault_ind".
#'
#' @return
#' A `ggplot` object that can be further customized using the `ggplot2` package.
#'
#' @examples
#' if (requireNamespace("ggplot2", quietly = TRUE)) {
#' library(ggplot2)
#' # Create study and agent
#' agent <- create_agents(
#'   agent_id = "Alice",
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   study_id = "Alice2022", agent_id = "Alice",
#'   N = 30, resources = 1000, cost = 400, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#' # Plot the probability distributions of remaining faults after the
#' # effect size was observed in the respective round
#' plot_distributions_heatmap(lit, "Alice2022", "after_effect")
#' }
#'
#' @export
plot_distributions_heatmap <- function(literature, study_id, type) {
  # Check if ggplot2 is available
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("The 'ggplot2' package is needed for this function to work. Please install it.", call. = FALSE)
  }
  # Assertions
  assert_literature(literature)
  assert(
    check_string(study_id),
    check_int(study_id, lower = 1)
  )
  assert_subset(study_id, setdiff(names(literature), c("complete_studies", "seed", "keep_seed_const")))
  assert_string(type)
  assert_choice(type, c("after_effect", "after_fault_ind"))

  # Extract desired study
  study <- literature[[study_id]]

  # Depending on type, use the appropriate conversion function
  df <- switch(
    type,
    after_effect = convert_p_after_fault_ind_to_long(study[["p_after_fault_ind"]]),
    after_fault_ind = convert_p_after_effect_to_long(study[["p_after_effect"]])
  )

  # Cut out rounds that were not performed
  n_rounds <- study[["stopped_in_round"]]
  df <- df[df[["round"]] <= n_rounds, ]

  # Variables for x-axis
  x_start <- min(df[["round"]])
  x_end <- max(df[["round"]])
  x_by_value <- if (x_end <= 20) 1 else round(x_end / 20)
  # Variables for y-axis
  y_start <- min(df[["n_faults_rem"]])
  y_end <- max(df[["n_faults_rem"]])
  y_by_value <- if (y_end <= 20) 1 else round(y_end / 20)

  subtitle <- switch(
    type,
    after_effect = "(after observation of effect sizes)",
    after_fault_ind = "(after observation of fault indicators)"
  )

  # Image generation
  ggplot2::ggplot(df, ggplot2::aes(x = round, y = n_faults_rem, fill = prob)) +
    ggplot2::geom_tile(alpha = 0.8) +
    ggplot2::scale_fill_gradient(low = "white", high = "black", limits = c(0, 1)) +
    ggplot2::scale_x_continuous(breaks = seq(x_start, x_end, by = x_by_value),
                                minor_breaks = NULL) +
    ggplot2::scale_y_continuous(breaks = seq(y_start, y_end, by = y_by_value),
                                minor_breaks = NULL) +
    ggplot2::labs(title = paste0("Probability Distribution for Number of Remaining Faults per Round\n", subtitle),
                  x = "Round", y = "# Remaining Faults") +
    ggplot2::theme_bw()
}

# Helper Functions for Wide to Long Conversion of Specific Matrices
convert_p_after_fault_ind_to_long <- function(p_matrix) {
  df <- t(as.data.frame(p_matrix))
  colnames(df) <- seq(0, ncol(df)-1)
  df <- cbind(
    data.frame(n_faults_rem = seq(0, nrow(df)-1)),
    df
  )
  df_long <- reshape(
    df,
    varying = list(names(df)[-1]),
    v.names = "prob",
    timevar = "round",
    times = names(df)[-1],
    idvar = "n_faults_rem",
    direction = "long"
  )
  rownames(df_long) <- NULL
  df_long[["round"]] <- as.integer(df_long[["round"]])
  df_long
}

convert_p_after_effect_to_long <- function(p_matrix) {
  df <- t(as.data.frame(p_matrix))
  colnames(df) <- seq(1, ncol(df))
  df <- cbind(
    data.frame(n_faults_rem = seq(0, nrow(df)-1)),
    df
  )
  df_long <- reshape(
    df,
    varying = list(names(df)[-1]),
    v.names = "prob",
    timevar = "round",
    times = names(df)[-1],
    idvar = "n_faults_rem",
    direction = "long"
  )
  rownames(df_long) <- NULL
  df_long[["round"]] <- as.integer(df_long[["round"]])
  df_long
}

# Suppress warnings about NAs in ggplot2 printing
suppress_na_warnings <- function(x) {
  tryCatch(
    print(x),
    warning = function(w) {
      if (grepl("rows containing missing values or values outside the scale range", w$message)) {
        return(suppressWarnings(print(x)))
      } else {
        warning(w)
      }
    }
  )
}
