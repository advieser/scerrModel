#' Summarize Simulated Literature Data
#'
#' This function summarizes the simulated literature returned by [simulate_literature].
#'
#' @param literature (`list`)\cr
#'   The simulated literature data, generated by [simulate_literature].
#' @param simple (`logical()`)\cr
#'   If `TRUE`, the output will be simplified to only contain a selection of key columns.
#'   If `FALSE` the output will also contain all columns of `complete_studies` passed to / created by [simulate_literature][`simulate_literature()`].
#'   Default is `TRUE`.
#'
#' @return (`data.frame`)\cr
#' A `data.frame` giving an overview over the simulated literature, with the following columns if `simple = FALSE`:
#' * `study_id` (`integer()` or `character()`)\cr
#'   The unique identifier of the study
#' * `agent_id` (`integer()` or `character()`)\cr
#'   The unique identifier of the agent who performed the data analysis.
#' * `N` (`integer()`)\cr
#'   Number of code units in the study.
#' * `resources` (`numeric()`)\cr
#'   Total resources available for the study.
#' * `cost` (`numeric()`)\cr
#'   Cost associated with one search round for the study.
#' * `benefit` (`numeric()`)\cr
#'   Benefit associated with one search round for the study.
#' * `bcr` (`numeric()`)\cr
#'   Benefit-cost ratio for the study.
#' * `n_rounds` (`integer()`)\cr
#'   Number of rounds the agent searched for faults.
#'   If `N+1`, this means that the agent finished the last round instead of stopping in the last round.
#' * `reason` (`character()`)\cr
#'   Reason for stopping the search. Can be "Search completed", "Expected utility too low" or "Resources depleted".
#' * `n_faults_total` (`integer()`)\cr
#'   Total number of faults in the study.
#' * `n_faults_discovered` (`integer()`)\cr
#'   Number of faults discovered by the agent.
#' * `n_faults_undiscovered` (`integer()`)\cr
#'   Number of faults not discovered by the agent.
#' * `real_effect_sizes` (`numeric()`)\cr
#'   Real effect size of the study (i.e. in the objective reality).
#' * `final_observed_effect_sizes` (`numeric()`)\cr
#'   Final observed effect size of the study in the round the agent stopped searching.
#' If `simple = TRUE` the returned `data.frame` contains all columns listed above as well as
#' all columns of `complete_studies` passed to / created by [simulate_literature][`simulate_literature()`].
#'
#' @examples
#' \dontrun{
#' # Create study and agent
#' agent <- create_agents(
#'   subj_effect_mu = 0.3, subj_effect_sigma = 1.2,
#'   subj_prob_fault_alpha = 0.2, subj_prob_fault_beta = 0.4,
#'   subj_error_size_mu = 0.6, subj_error_size_sigma = 0.2
#' )
#' study <- create_studies(
#'   study_id = "Alice2022", agent_id = "Alice",
#'   N = 30, resources = 1000, cost = 400, benefit = 20,
#'   obj_effect_mu = 0.4, obj_effect_sigma = 0.5,
#'   obj_prob_fault = 0.4,
#'   obj_error_size_mu = 0.1, obj_error_size_sigma = 0.2
#' )
#'
#' # Simulate the study
#' lit <- simulate_literature(agents = agent, studies = study, seed = 123)
#'
#' # Summarize the literature (simple = TRUE)
#' simulation_summary(lit)
#'
#' # Extensive Summary with all input parameters
#' ext_summary <- simulation_summary(lit, simple = FALSE)
#'
#' # You can then index the information you need
#' ext_summary[, c("study_id", "agent_id", "subj_effect_mu", "subj_effect_sigma", "N",
#'                 "n_faults_discovered", "n_faults_undiscovered")]
#' }
#'
#' @export
simulation_summary <- function(literature, simple = TRUE) {
  assert_list(literature, names = "named")

  # Extract the complete studies
  cs <- literature[["complete_studies"]]
  # Simplify literature to only include the studies
  studies <- literature[-c(1, 2, 3)]

  # Extract vector of remaining resources per study
  remaining_resources <- vapply(studies, function(x) x[["remaining_resources"]], numeric(1))
  # Extract vector of number of rounds the agents searched per study
  n_rounds <- vapply(studies, function(x) x[["stopped_in_round"]], numeric(1))
  # Extract vector of reasons for stopping per study
  reason <- vapply(studies, function(x) x[["stopping_reason"]], character(1))
  # Extract vector of number of total faults per study
  n_faults_total <- vapply(studies, function(x) sum(x[["fault_indicators"]]), numeric(1))
  # Extract vector of number of discovered faults per study
  n_faults_discovered <- vapply(studies, function(x) {
    # 0 since stopping in first round should not count as the fault having been discovered (and is ignored in sum)
    # -1 since in the last round error indicator was not observed before stopping
    indices <- seq(0, x[["stopped_in_round"]] - 1)
    sum(x[["fault_indicators"]][indices])
  }, numeric(1))
  # Extract vector of number of undiscovered faults per study
  n_faults_undiscovered <- vapply(studies, function(x) {
    start_index <- x[["stopped_in_round"]] + 1
    end_index <- length(x[["fault_indicators"]])

    # Create a sequence only if the start index is less than or equal to the end index
    indices <- if (start_index <= end_index) seq(start_index, end_index) else integer(0)

    sum(x[["fault_indicators"]][indices], na.rm = TRUE)
  }, numeric(1))
  # Extract vector of real effect sizes per study
  real_effect_sizes <- vapply(studies, function(x) x[["obj_effect_size"]], numeric(1))
  # Extract vector of final observed effect sizes per study
  final_observed_effect_sizes <- vapply(studies, function(x) x[["observed_effect_sizes"]][x[["stopped_in_round"]]], numeric(1))

  if (simple) {
    data.frame(
      study_id = cs$study_id,
      agent_id = cs$agent_id,
      N = cs$N,
      resources_before = cs$resources,
      resources_after = remaining_resources,
      cost = cs$cost,
      benefit = cs$benefit,
      bcr = cs$benefit / cs$cost,
      n_rounds = unname(n_rounds),
      reason = unname(reason),
      n_faults_total = unname(n_faults_total),
      n_faults_discovered = unname(n_faults_discovered),
      n_faults_undiscovered = unname(n_faults_undiscovered),
      real_effect_size = unname(real_effect_sizes),
      final_observed_effect_size = unname(final_observed_effect_sizes)
    )
  } else {
    merge(
      cs,
      data.frame(
        study_id = cs$study_id,
        remaining_resources = remaining_resources,
        bcr = cs$benefit / cs$cost,
        n_rounds = n_rounds,
        reason = reason,
        n_faults_total = n_faults_total,
        n_faults_discovered = n_faults_discovered,
        n_faults_undiscovered = n_faults_undiscovered,
        real_effect_size = real_effect_sizes,
        final_observed_effect_size = final_observed_effect_sizes
      ),
      by = "study_id"
    )
  }
}
